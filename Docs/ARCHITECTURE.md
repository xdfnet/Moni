# 系统架构

## 概述

Moni 采用现代化的分层架构设计，通过清晰的职责分离、模块化组件和优化的代码结构，实现了一个高效、可维护的网络监控系统。本文档详细描述了系统的整体架构、组件设计和交互流程。

## 架构概览

### 系统架构图

```text
┌─────────────────────────────────────────────────────────────┐
│                        Moni 应用                            │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   App.swift │  │MenuBarCtrl  │  │  Utilities  │        │
│  │             │  │             │  │             │        │
│  │ 应用入口点   │  │ 菜单栏控制  │  │ 工具函数库  │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │BaseMonitor  │  │MonitorLat   │  │MonitorNet   │        │
│  │             │  │             │  │             │        │
│  │ 基础监控类   │  │ 延迟监控    │  │ 网络监控    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ServiceMgr   │  │ConfigMgr    │  │SharedTypes  │        │
│  │             │  │             │  │             │        │
│  │ 服务管理    │  │ 配置管理    │  │ 共享类型    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
├─────────────────────────────────────────────────────────────┤
│                    macOS 系统层                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │Network.fw   │  │   sysctl    │  │  Cocoa      │        │
│  │             │  │             │  │             │        │
│  │ TCP 连接    │  │ 系统统计    │  │ UI 框架     │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

### 架构层次

1. **应用层**：用户界面和生命周期管理
2. **业务层**：监控逻辑和数据处理
3. **服务层**：服务管理和配置管理
4. **基础设施层**：网络通信和系统调用

## 核心组件

### 1. 应用入口 (App.swift)

#### 职责
- 应用生命周期管理
- 系统事件监听（睡眠/唤醒）
- 菜单栏管理器初始化

#### 设计特点
- 使用 SwiftUI 的 `@main` 协议
- 通过 `AppDelegate` 管理应用状态
- 支持系统睡眠/唤醒事件处理

#### 代码结构
```swift
@main
struct MoniApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    var body: some Scene {
        Settings { EmptyView() }
    }
}
```

### 2. 菜单栏控制器 (MenuBarController.swift)

#### 职责
- 状态栏图标显示和管理
- 用户菜单界面
- 监控状态协调

#### 设计特点
- 协调 `MonitorLatency` 与 `MonitorNetwork` 的启停
- 动态菜单创建，避免菜单粘连
- 实时状态更新和显示

#### 关键功能
- 显示模式切换（Service/Network）
- 监控间隔配置
- 服务选择菜单
- 状态指示器

### 3. 基础监控类 (BaseMonitor.swift)

#### 职责
- 定义监控基础流程
- 提供通用的资源管理
- 支持可配置的监控间隔

#### 设计特点
- 抽象基类，定义监控接口
- 使用模板方法模式
- 线程安全的定时器管理

#### 核心方法
```swift
protocol BaseMonitorProtocol: AnyObject {
    var isMonitoring: Bool { get }
    func startMonitoring()
    func stopMonitoring()
    func cleanup()
}
```

### 4. 延迟监控 (MonitorLatency.swift)

#### 职责
- TCP 连接延迟测量
- 连接状态管理
- 延迟数据回调

#### 技术实现
- 使用 Network.framework 建立 TCP 连接
- 测量连接建立时间
- 超时处理和错误管理

#### 设计特点
- 继承 `BaseMonitor` 基类
- 使用代理模式通知结果
- 支持连接超时和失败处理

### 5. 网络监控 (MonitorNetwork.swift)

#### 职责
- 系统网络流量统计
- 下载速度计算
- 网络接口状态监控

#### 技术实现
- 通过 sysctl 获取网络统计信息
- 计算单位时间内的数据变化
- 异常数据检测和处理

#### 设计特点
- 智能过滤网络接口
- 数据有效性验证
- 自动重置异常统计

### 6. 服务管理器 (ServiceManager.swift)

#### 职责
- 服务端点配置管理
- 服务分类组织
- 端点验证

#### 设计特点
- 单例模式，全局访问
- 按类别组织服务
- 支持服务端点验证

#### 服务分类
- **AI 服务**：Claude、Gemini、DeepSeek、GLM、Kimi
- **开发工具**：Homebrew、NPM、PyPI、Maven
- **网络服务**：Docker Hub、Cursor

### 7. 配置管理器 (ConfigurationManager.swift)

#### 职责
- 用户配置持久化
- 配置导入导出
- 配置变更通知

#### 设计特点
- 使用 UserDefaults 存储配置
- 支持 JSON 格式导入导出
- 线程安全的配置操作

#### 配置项
- 显示模式选择
- 监控间隔设置
- 服务选择偏好
- 通知设置

### 8. 共享类型 (SharedTypes.swift)

#### 职责
- 定义应用常量
- 共享数据结构
- 类型定义

#### 核心类型
- `ServiceEndpoint`：服务端点结构
- `ConnectionStatus`：连接状态枚举
- `MonitorConstants`：监控相关常量
- `AppConstants`：应用常量

### 9. 工具函数库 (Utilities.swift)

#### 职责
- 提供通用工具函数
- 统一常用功能
- 减少代码重复

#### 功能分类
- **格式化工具**：`formatLatency`, `formatSpeed`, `formatInterval`
- **时间工具**：`currentTimestamp`, `timeDifference`
- **线程安全工具**：`safeMainQueueCallback`
- **数值工具**：`safeInt`, `clamp`, `validateServiceEndpoint`
- **性能工具**：`measureExecutionTime`
- **调试工具**：`debugPrint`, `printPerformanceStats`

## 设计模式

### 1. 单例模式 (Singleton)

#### 应用场景
- `ServiceManager.shared`：全局服务管理
- `ConfigurationManager.shared`：全局配置管理

#### 优势
- 确保全局唯一实例
- 简化访问方式
- 统一状态管理

### 2. 代理模式 (Delegate)

#### 应用场景
- `MonitorLatencyDelegate`：延迟监控结果回调
- `MonitorNetworkDelegate`：网络监控结果回调

#### 优势
- 松耦合的组件通信
- 支持多个监听者
- 类型安全的回调

### 3. 模板方法模式 (Template Method)

#### 应用场景
- `BaseMonitor` 定义监控流程
- 子类实现具体监控逻辑

#### 优势
- 统一的监控流程
- 减少重复代码
- 易于扩展新监控类型

### 4. 观察者模式 (Observer)

#### 应用场景
- 配置变更通知
- 状态变化更新
- 系统事件监听

#### 优势
- 松耦合的事件处理
- 支持一对多通知
- 自动状态同步

### 5. 策略模式 (Strategy)

#### 应用场景
- 不同的监控策略
- 可配置的监控间隔
- 灵活的服务选择

#### 优势
- 运行时策略切换
- 易于添加新策略
- 配置驱动的行为

## 数据流

### 1. 延迟监控数据流

```text
用户选择服务 → ServiceManager 获取端点 → MonitorLatency 建立连接 → 
测量延迟时间 → 通过代理回调 → MenuBarController 更新显示
```

### 2. 网络监控数据流

```text
定时器触发 → MonitorNetwork 获取系统统计 → 计算下载速度 → 
验证数据有效性 → 通过代理回调 → MenuBarController 更新显示
```

### 3. 配置管理数据流

```text
用户修改配置 → ConfigurationManager 保存 → 通知相关组件 → 
更新监控参数 → 重新启动监控
```

## 线程模型

### 1. 主线程 (Main Thread)

#### 职责
- 用户界面更新
- 用户交互处理
- 配置变更处理

#### 安全保证
- 使用 `Utilities.safeMainQueueCallback` 确保主线程回调
- 避免阻塞主线程的耗时操作

### 2. 监控队列 (Monitor Queue)

#### 职责
- 网络连接建立
- 系统统计获取
- 数据处理计算

#### 特点
- 专用队列，避免阻塞
- 支持并发操作
- 资源隔离

### 3. 配置队列 (Configuration Queue)

#### 职责
- 配置读写操作
- 配置导入导出
- 配置变更通知

#### 特点
- 串行队列，保证顺序
- 线程安全的操作
- 避免竞态条件

## 错误处理

### 1. 错误类型

#### 网络错误
- 连接超时
- 连接失败
- 网络不可达

#### 系统错误
- 权限不足
- 资源不足
- 配置错误

#### 数据错误
- 无效数据
- 数据范围异常
- 格式错误

### 2. 错误处理策略

#### 重试机制
- 连接失败自动重试
- 指数退避策略
- 最大重试次数限制

#### 降级处理
- 网络不可用时显示离线状态
- 配置错误时使用默认值
- 系统资源不足时暂停监控

#### 用户通知
- 清晰的错误信息
- 解决建议
- 调试信息记录

## 性能优化

### 1. 内存管理

#### 策略
- 使用弱引用避免循环引用
- 及时释放网络连接资源
- 缓存关键数据减少重复计算

#### 监控
- 内存使用量监控
- 内存泄漏检测
- 资源清理日志

### 2. 网络优化

#### 策略
- 连接复用
- 超时设置合理
- 并发连接控制

#### 监控
- 网络延迟统计
- 连接成功率
- 带宽利用率

### 3. CPU 优化

#### 策略
- 智能调度监控任务
- 避免不必要的计算
- 使用高效的算法

#### 监控
- CPU 使用率
- 任务执行时间
- 性能瓶颈分析

## 扩展性设计

### 1. 服务扩展

#### 添加新服务
- 在 `ServiceManager` 中注册新端点
- 支持自定义的服务分类
- 可配置的监控参数

#### 监控策略扩展
- 继承 `BaseMonitor` 实现新监控类型
- 支持不同的网络协议
- 可扩展的数据处理逻辑

### 2. 界面扩展

#### 菜单扩展
- 添加新的配置选项
- 支持自定义的显示模式
- 可扩展的状态指示器

#### 数据展示扩展
- 支持图表和统计信息
- 可配置的数据导出格式
- 支持历史数据查看

### 3. 功能扩展

#### 监控类型扩展
- 支持更多网络协议
- 支持更多系统指标
- 支持更多数据源

#### 集成扩展
- 支持第三方监控系统
- 支持数据导出到外部系统
- 支持远程配置管理

## 安全考虑

### 1. 权限管理

#### 网络权限
- 网络访问权限申请
- 本地网络权限控制
- 网络数据安全传输

#### 系统权限
- 系统监控权限
- 文件访问权限
- 用户配置权限

### 2. 数据安全

#### 配置数据
- 本地加密存储
- 敏感信息保护
- 数据访问控制

#### 监控数据
- 数据脱敏处理
- 隐私信息保护
- 数据生命周期管理

## 测试策略

### 1. 单元测试

#### 测试范围
- 核心业务逻辑
- 工具函数
- 数据验证

#### 测试工具
- XCTest 框架
- Mock 对象
- 测试数据生成

### 2. 集成测试

#### 测试范围
- 组件间交互
- 数据流完整性
- 错误处理流程

#### 测试环境
- 模拟网络环境
- 模拟系统状态
- 自动化测试脚本

### 3. 性能测试

#### 测试指标
- 响应时间
- 资源占用
- 并发能力

#### 测试工具
- Instruments 性能分析
- 压力测试脚本
- 性能基准测试

## 部署和运维

### 1. 构建系统

#### Makefile 支持
- 自动化构建流程
- 版本管理
- 代码质量检查

#### 发布流程
- 版本号管理
- 构建产物管理
- 发布验证

### 2. 监控和日志

#### 应用监控
- 性能指标收集
- 错误日志记录
- 用户行为分析

#### 系统监控
- 资源使用监控
- 网络状态监控
- 系统事件监控

## 总结

Moni 的架构设计充分体现了现代软件工程的最佳实践：

1. **分层清晰**：每一层都有明确的职责和边界
2. **模块化设计**：组件间松耦合，易于维护和扩展
3. **性能优化**：合理的线程模型和资源管理
4. **错误处理**：完善的错误处理机制和用户反馈
5. **扩展性**：支持新功能和新监控类型的扩展
6. **安全性**：考虑了权限管理和数据安全
7. **可测试性**：支持单元测试、集成测试和性能测试

这种架构设计确保了系统的稳定性、可维护性和可扩展性，为用户提供了可靠、高效的网络监控体验。
